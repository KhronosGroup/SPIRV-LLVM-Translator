; The test is generated by Clang from the following source:
;
; void foo8(unsigned char a, unsigned char b, unsigned char *c) {
;   if (a * b > 255)
;     *c = 0;
;   else
;     *c = a * b;
; }

; void foo32(unsigned int a, unsigned int b, unsigned int* c) {
;   *c = a * b;
;   if (a != *c / b)
;     *c = 0;
; }
;
; With the following options:
; -emit-llvm -fno-discard-value-names -O2 -g0 -ftrapv -target spir

; RUN: llvm-as < %s -o %t.bc
; RUN: llvm-spirv -s %t.bc -o - | llvm-dis -o - | FileCheck %s

; CHECK: call { i8, i1 } @llvm_umul_with_overflow_i8
; CHECK-NOT: call { i8, i1 } @llvm.umul.with.overflow.i8

; CHECK: call { i32, i1 } @llvm_umul_with_overflow_i32
; CHECK-NOT: call { i32, i1 } @llvm.umul.with.overflow.i32

; CHECK-NOT: call { i16, i1 } @llvm_umul_with_overflow_i16
; CHECK-NOT: call { i64, i1 } @llvm_umul_with_overflow_i64


target datalayout = "e-p:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024"
target triple = "spir"

; Function Attrs: nofree nounwind writeonly
define dso_local spir_func void @_Z4foo8hhPh(i8 zeroext %a, i8 zeroext %b, i8* nocapture %c) local_unnamed_addr #0 {
entry:
  %umul = tail call { i8, i1 } @llvm.umul.with.overflow.i8(i8 %a, i8 %b)
  %cmp = extractvalue { i8, i1 } %umul, 1
  %umul.value = extractvalue { i8, i1 } %umul, 0
  %storemerge = select i1 %cmp, i8 0, i8 %umul.value
  store i8 %storemerge, i8* %c, align 1, !tbaa !2
  ret void
}

; Function Attrs: nofree nounwind writeonly
define dso_local spir_func void @_Z5foo32jjPj(i32 %a, i32 %b, i32* nocapture %c) local_unnamed_addr #0 {
entry:
  %umul = tail call { i32, i1 } @llvm.umul.with.overflow.i32(i32 %b, i32 %a)
  %umul.val = extractvalue { i32, i1 } %umul, 0
  %umul.ov = extractvalue { i32, i1 } %umul, 1
  %spec.select = select i1 %umul.ov, i32 0, i32 %umul.val
  store i32 %spec.select, i32* %c, align 4, !tbaa !5
  ret void
}

; Function Attrs: nounwind readnone speculatable willreturn
declare { i8, i1 } @llvm.umul.with.overflow.i8(i8, i8) #1

; Function Attrs: nounwind readnone speculatable willreturn
declare { i32, i1 } @llvm.umul.with.overflow.i32(i32, i32) #1

attributes #0 = { nofree nounwind writeonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone speculatable willreturn }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 12.0.0 (https://github.com/llvm/llvm-project.git ddcc7ce59150c9ebc6b0b2d61e7ef4f2525c11f4)"}
!2 = !{!3, !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C++ TBAA"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !3, i64 0}
